# DFS

## [蓝桥杯 2013 省 A] 大臣的旅费

### 题目描述

很久以前，T 王国空前繁荣。为了更好地管理国家，王国修建了大量的快速路，用于连接首都和王国内的各大城市。

为节省经费，T 国的大臣们经过思考，制定了一套优秀的修建方案，使得任何一个大城市都能从首都直接或者通过其他大城市间接到达。同时，如果不重复经过大城市，从首都到达每个大城市的方案都是唯一的。

J 是 T 国重要大臣，他巡查于各大城市之间，体察民情。所以，从一个城市马不停蹄地到另一个城市成了 J 最常做的事情。他有一个钱袋，用于存放往来城市间的路费。

聪明的 J 发现，如果不在某个城市停下来修整，在连续行进过程中，他所花的路费与他已走过的距离有关，在走第 $x$ 千米到第 $x+1$ 千米这一千米中（$x$ 是整数），他花费的路费是 $x+10$ 这么多。也就是说走 $1$ 千米花费 $11$，走 $2$ 千米要花费 $23$。

J 大臣想知道：他从某一个城市出发，中间不休息，到达另一个城市，所有可能花费的路费中最多是多少呢？

### 输入格式

输入的第一行包含一个整数 $n(n \le 10^5)$，表示包括首都在内的 $T$ 王国的城市数。

城市从 $1$ 开始依次编号，$1$ 号城市为首都。

接下来 $n-1$ 行，描述 $T$ 国的高速路（$T$ 国的高速路一定是 $n-1$ 条）。

每行三个整数 $P_i,Q,D_i$，表示城市 $P_i$ 和城市 $Q_i$ 之间有一条高速路，长度为 $D_i(D_i \le 1000)$ 米。





树的直径：树中长度最长的路径。

求树的直径的步骤：

1. 任取一点 *x* ;
2. 找到距离 *x* 最远的点 *y* ;
3. 从 *y* 开始遍历，找到离 *y* 最远的点，与 *y* 最远的点的距离是树的直径;

这道题我们可以使用深搜来解决。

AC代码

```cpp
#include <bits/stdc++.h>
using namespace std;

const int N=1e5+10;
int dis[N];
struct edge
{
	int q,d;	
};
vector<edge> m[N];
bitset<N> vis;
void dfs(int u,int father,int distance)
{
	dis[u]=distance;
	vis[u]=1;
	for(int i=0;i<m[u].size();i++)
	{
		if(!vis[m[u][i].q])
		dfs(m[u][i].q,u,dis[u]+m[u][i].d);
	}
}
int main(void)
{
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	int n=0;
	cin>>n;
	int x,y,d;
	while(cin>>x>>y>>d)
	{
		m[x].push_back({y,d});
		m[y].push_back({x,d});
	}
	dfs(1,-1,0);
	int u=0,mx=-1;
	for(int i=1;i<=n;i++)
	{
		if(dis[i]>mx) u=i,mx=dis[i];
	}
	vis=0;
	dfs(u,-1,0);
	
	int distance=*max_element(dis+1,dis+1+n);
	int res=distance*10;
	for(int i=1;i<=distance;i++)
	{
		res+=i;
	}
	cout<<res;
	return 0;
 } 
```

# 记忆化搜索

## [蓝桥杯 2014 省 AB] 地宫取宝

### 题目描述

X 国王有一个地宫宝库。是 $n \times m$ 个格子的矩阵。每个格子放一件宝贝。每个宝贝贴着价值标签。

地宫的入口在左上角，出口在右下角。

小明被带到地宫的入口，国王要求他只能向右或向下行走。

走过某个格子时，如果那个格子中的宝贝价值比小明手中任意宝贝价值都大，小明就可以拿起它（当然，也可以不拿）。

当小明走到出口时，如果他手中的宝贝恰好是 $k$ 件，则这些宝贝就可以送给小明。

请你帮小明算一算，在给定的局面下，他有多少种不同的行动方案能获得这 $k$ 件宝贝。

### 输入格式

输入一行 $3$ 个整数，用空格分开：$n$，$m$，$k(1 \le n,m \le 50,1 \le k \le 12)$。

接下来有 $n$ 行数据，每行有 $m$ 个整数 $C_i(0 \le C_i \le 12)$ 代表这个格子上的宝物的价值。

### 输出格式

要求输出一个整数，表示正好取 $k$ 个宝贝的行动方案数。该数字可能很大，输出它对 $1000000007(10^9+7)$ 取模的结果。



很容易想到 DFS+记忆化搜索优化

```cpp
#include<cstdio>
#include<algorithm>
#include<cstring>
using namespace std;
int n,m,k,a[60][60],s[60][60][15][15];
int dfs(int x,int y,int maxx,int step){
	if (x==n+1||y==m+1)return 0;//边界条件。
	if (s[x][y][maxx+1][step]!=-1)return s[x][y][maxx+1][step];//记忆化搜索。
	long long cnt=0;
	if (x==n&&y==m){
		if (step==k||(step==k-1&&a[x][y]>maxx))
			cnt++;
	}
	else {
		cnt+=dfs(x,y+1,maxx,step);
		if (a[x][y]>maxx)cnt+=dfs(x,y+1,a[x][y],step+1);
		cnt+=dfs(x+1,y,maxx,step);
		if (a[x][y]>maxx)cnt+=dfs(x+1,y,a[x][y],step+1);//怎样搜索。
	}
	s[x][y][maxx+1][step]=cnt%1000000007;
	return s[x][y][maxx+1][step];
}
int main(){
	scanf ("%d%d%d",&n,&m,&k);
	for (int i=1;i<=n;i++)
		for (int j=1;j<=m;j++)
			scanf ("%d",&a[i][j]);//读入
	memset(s,-1,sizeof(s));//赋值为 -1。
	printf ("%d",dfs(1,1,-1,0));
	return 0;
}
```

# 树状数组

## [蓝桥杯 2014 省 B] 小朋友排队

### 题目描述

$n$ 个小朋友站成一排。现在要把他们按身高从低到高的顺序排列，但是每次只能交换位置相邻的两个小朋友。

每个小朋友都有一个不高兴的程度。开始的时候，所有小朋友的不高兴程度都是 $0$。

如果某个小朋友第一次被要求交换，则他的不高兴程度增加 $1$，如果第二次要求他交换，则他的不高兴程度增加 $2$（即不高兴程度为 $3$），依次类推。当要求某个小朋友第 $k$ 次交换时，他的不高兴程度增加 $k$。

请问，要让所有小朋友按从低到高排队，他们的不高兴程度之和最小是多少。

如果有两个小朋友身高一样，则他们谁站在谁前面是没有关系的。

### 输入格式

输入的第一行包含一个整数 $n$，表示小朋友的个数。

第二行包含 $n$ 个整数 $H_1,H_2 \cdots H_n$，分别表示每个小朋友的身高。

### 输出格式

输出一行，包含一个整数，表示小朋友的不高兴程度和的最小值。



**树状数组求逆序对**

# DP

## [蓝桥杯 2015 省 AB] 垒骰子

### 题目描述

赌圣 atm 晚年迷恋上了垒骰子，就是把骰子一个垒在另一个上边，不能歪歪扭扭，要垒成方柱体。

经过长期观察，atm 发现了稳定骰子的奥秘：有些数字的面贴着会互相排斥！

我们先来规范一下骰子：$1$ 的对面是 $4$，$2$ 的对面是 $5$，$3$ 的对面是 $6$。

假设有 $m$ 组互斥现象，每组中的那两个数字的面紧贴在一起，骰子就不能稳定的垒起来。

atm 想计算一下有多少种不同的可能的垒骰子方式。

两种垒骰子方式相同，当且仅当这两种方式中对应高度的骰子的对应数字的朝向都相同。

由于方案数可能过多，请输出模 $10^9+7$ 的结果。

不要小看了 atm 的骰子数量哦～。

### 输入格式

第一行两个整数 $n$，$m$。

$n$ 表示骰子数目。

接下来 $m$ 行，每行两个整数 $a$，$b$，表示 $a$ 和 $b$ 数字不能紧贴在一起。

### 输出格式

一行一个数，表示答案模 $10^9+7$ 的结果。

