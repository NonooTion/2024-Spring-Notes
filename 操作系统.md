# 操作系统概念

# 第一章 操作系统概述

## 1.1.1 操作系统的概念、功能

**操作系统的概念(定义)**

`操作系统`(Operating System,OS) 是指控制和**管理**整个计算机系统的**硬件和软件**资源(操作系统是系统资源的管理者)，并合理地组织调度计算机地工作和资源的分配；以**提供给用户和其他软件方便的接口和环境**(给上层提供方便易用的服务)；它是计算机系统中最基本的**系统软件**（最接近硬件的软件）

**计算机的层次结构(自顶向上)**

裸机(纯硬件)

操作系统

应用程序(软件)

用户



  **操作系统的功能和目标**

1. 作为系统资源的管理者

**提供的功能**

- 处理机管理
- 存储器管理
- 文件管理
- 设备管理

**目标->安全、高效**

2. 向上层提供方便易用的服务

**封装思想:** 操作系统把一些难以直接使用的硬件功能封装成简单易用的服务，使用户能更方便地使用计算机，用户无需关心底层硬件的原理，只需要对操作系统发出命令即可

`GUI`：图形化用户结构(Graphical User Interface)

用户可以使用形象的图形界面进行操作，而不再需要记忆复杂的命令、参数。

**用户接口**

`命令接口`(command interface)

**联机命令接口**实例(Windows系统) 联机命令接口=`交互式`命令接口

用户每次提出一个请求，系统跟着解决请求

**脱机命令接口**实例(Windows系统) 脱机命令接口=`批处理`命令接口

用户提出一个或多个请求，系统一次解决请求



`程序接口`(Application Programming Interface)

可以在程序中进行`系统调用`来使用程序接口。普通用户不能直接使用程序接口，只能通过程序代码**间接**使用

系统调用类似函数调用，是应用程序请求操作系统服务的唯一方式

如:C语言库函数中的printf函数的底层就使用到了操作系统提供的显式相关的系统调用

系统调用也叫做`广义指令`

3. 实现对硬件机器的拓展

没有任何软件支持的计算机成为`裸机`。在裸机上安装的操作系统，可以提供资源管理功能和方便用户的服务功能，将裸机改造成功能更强、使用更方便的机器。

通常把覆盖了软件的机器称为`扩展机器`，又称之为`虚拟机`



## 1.1.2 操作系统的四个特征

- 并发
- 共享

并发和共享是操作系统最基本的特征，二者互为存在条件

- 虚拟
- 异步



1. 操作系统的并发性

`并发`：两件或多个事件在统一时间间隔内发生。这些事件**宏观上是同时发生的**，但**微观上是交替发生**的

与 `并行` 区分，并行是指两个或多个事件在同一时刻同时发生

**操作系统的并发性** 指计算机系统中"同时"运行着多个程序，这些程序宏观上看是同时运行着的，而微观上看是交替运行的。

操作系统就是伴随着"多道程序技术"而出现的。因此，**操作系统和程序并发是一起诞生的**

2. 操作系统的共享性

`共享`即资源共享，是指系统中的资源可供内存中多个并发执行的进程共同使用

两种资源共享方式：

- 互斥共享方式：系统中的某些资源，虽然可以提供给多个进程使用，但 **一个时间段内只允许一个进程访问该资源**

- 同时共享方式：系统中的某些资源，**允许一个时间段内由多个进程"同时"对它们进行访问**

  宏观上看，多个进程同时访问资源，微观上看，两个进程是交替着访问资源

**并发和共享的关系**

`并发性`指计算机系统中同时存在着多个运行着的程序

`共享性`是指系统中的资源可供内存中多个并发执行的进程共同使用

如果失去并发性，则系统中只有一个程序正在运行，则共享性失去存在的意义

如果失去共享性，则进程不能同时访问系统资源，也就无法并发

**所以并发性和共享性 互为存在条件**

3. 虚拟

一个程序需要放入内存并给它分配CPU才能执行

`虚拟`是指把一个物理上的实体变为若干个逻辑上的对应物。物理实体是实际存在的，而逻辑上对应物是用户感受到的

**虚拟技术：**

空分复用技术  如：虚拟存储器技术

时分复用技术  如：虚拟处理器技术

如果失去了并发性，一个时间段内只需运行一道程序，那么就失去了实现虚拟性的意义了。**没有并发性就谈不上虚拟性**

4. 异步

`异步` 是指，在多道程序环境，允许多个程序并发执行，但由于资源有限，进程的执行不是一贯到底的，而是走走停停，以不可预知的速度向前推进，这就是进程的异步性

**只有系统拥有并发性，才有可能导致异步性**

## 1.2 操作系统的发展和分类

1. 手工操作阶段

主要缺点：用户独占全机、人机速度矛盾导致资源利用率极低

2. 批处理阶段--单道批处理系统

引入`脱机输入/输出技术`，并由`监督程序`负责控制作业的输入、输出

通过外围机把程序提前存到磁带里

优点：缓解了一定程度的人机速度矛盾，资源的利用率有所提升

主要缺点：**内存中仅能由一道程序运行**，只有该程序运行结束后才能调入下一道程序。**CPU有大量的时间实在空闲等待I/O完成。资源利用率依然很低**

3. 批处理阶段--多道批处理系统

每次往内存中读入多道程序

操作系统正式诞生，用于支持多道程序并发运行

主要优点：多道程序 **并发** 执行，共享计算机资源。 **资源利用率大幅度提升**，系统吞吐量大

主要缺点：用户响应时间长， **没有人机交互功能** ->无法调试程序，无法在程序运行过程中输入一些参数...

4. 分时操作系统

计算机以 `时间片` 为单位 **轮流为各个用户/作业服务**，各个用户可通过终端与计算机进行交互

主要优点：用户请求可以被及时响应，**解决了人机交互问题**。允许多个用户同时使用一台计算机，并且用户对计算机的操作相互独立，感受不到其他人的存在

5. 实时操作系统

优点：能够优先响应一些紧急任务，某些紧急任务不需时间片排队

在实时操作系统的控制下，计算机系统接收到外部信息后及时进行处理，并且 **要在严格的时限内处理完时间**。实时操作系统的主要特点是 **及时性和可靠性**

- 硬实时系统 必须在绝对严格的规定时间内完成处理
- 软实时系统 能接受偶尔违反时间规定

6. 其他

- 网络操作系统

伴随计算机网络发展诞生，能把网络中各个计算机有机结合起来，实现数据传送等功能 ，**实现网络中各种资源的共享(如文件共享)和各台计算机之间的通信** 

- 分布式操作系统

主要特点是 **分布性和并行性**。系统中的各台计算机地位相同， **任何工作可以分布在这些计算机上，由它们并行、协同完成这个任务**

- 个人计算机操作系统

 如 Windows XP , MacOS

## 1.3.1 操作系统的运行机制

**内核程序与应用程序**

`应用程序`：普通程序员写的程序

`内核程序`：`(操作系统)内核`(Kernel)是操作系统最重要最核心的部分，它是由很多内核程序组成的



**特权指令与非特权指令**

**操作系统内核**作为"管理者"，有时会让CPU执行一些"特权指令",如：内存清零指令。这些指令影响重大，只允许"管理者"，即操作系统内核来使用



**CPU设计和生成的时候就划分了特权指令和非特权指令**

应用程序只能够使用非特权指令



**内核态和用户态**

CPU有两种状态,`内核态`和`用户态`

处于**内核态**时，说明此时正在运行的是**内核程序**，此时**可以执行特权指令**

处于**用户态**时，说明此时正在运行的是**应用程序**，此时**只能执行非特权指令**



CPU中有一个寄存器叫做`程序状态寄存器(PSW)`，其中有个二进制位，用来表示此时CPU处于内核态或者用户态



内核态=核心态=管态

用户态=目态



**内核态、用户态的切换**

开机时，CPU为**内核态**，操作系统内核程序现在CPU运行

开机后，用户可以启动某个应用程序

操作系统内核程序在合适的时候主动让出CPU，让该应用程序上CPU运行。（操作系统在让出CPU之前，会用一条特权指令把PSW的标志位设置为"用户态")

如果应用程序中植入了一条特权指令，CPU此时处于"用户态"。这个非法事件会引发一个 **中断信号**

CPU检测到中断信号后，会立即 **变为核心态** 并且停止运行当前的应用程序，转而运行处理中断信号的内核程序





1. **内核态->用户态**:执行一条 **特权指令**，修改PSW的标志位为"用户态"，这个动作意味着操作系统将主动让出CPU使用权
2. **用户态->内核态**：由**“中断”**引发，**硬件自动完成变态过程**，触发中断信号意味着操作系统将强行夺回CPU的使用权。出了非法使用特权指令之外，还有很多事件会触发中断信号。**一个共性是，但凡需要操作系统介入的地方，都会触发中断信号**。

## 1.3.2 中断和异常

**中断的作用**

CPU上会运行两种程序，操作系统的内核程序和应用程序

中断是 **让操作系统内核夺回CPU使用权** 的唯一途径(CPU由用户态变为内核态)

如果没有中断机制，那么一旦应用程序在CPU上运行，CPU就会一致运行这个应用程序



**中断的类型**

`内中断`(异常) 与当前执行的指令有关，中断信号来源自CPU内部

- 试图在用户态下执行特权指令
- 执行除法指令时发现除数为0
- 应用程序想要请求操作系统内核的服务，此时会执行**一条特殊的指令--陷入指令** 会引发一个内部中断信号 它是非特权指令

`外中断` (中断)与当前执行的指令无关，中断信号来源自CPU外部

- 时钟中断--始终不见发来的中断信号
- I/O中断--由输入/输出设备发来的中断信号

CPU在每条指令执行结束的时候，都会例行检查是否有外中断信号



**内中断(异常、例外)的分类**

- `陷阱、陷入`(trap)->由陷入指令引发，是应用程序故意引发的

- `故障`(fault)->由错误条件引起，有可能被内核程序修复。修复后会把CPU使用权归还给应用程序
- `终止`(abort)->由致命错误引起，内核程序无法修复该错误，因此一般不再将CPU使用权归还给引发终止的应用程序，而是直接终止该应用程序

**外中断(中断)的分类**

- `时钟中断`
- `I/O中断请求`



**中断机制的基本**

不同的中断信号，需要用不同的中断处理程序来处理。CPU检测到中断信号后，会根据中断信号的类型取查询**"中断向量表"** 以此来找到相应的**中断处理程序（是内核程序，需要在内核态下运行）**在内存中的存放位置



## 1.3.3 系统调用

**系统调用的概念**

操作系统作为用户和计算机硬件的接口，需要向上提供一些简单易用的服务。主要包括命令接口和程序接口。其中，程序接口由一组**系统调用**组成



系统调用是操作系统提供给应用程序(程序员/编程人员)使用的接口，可以理解为一种可供应用程序调用的特殊函数,**应用程序可以通过系统调用来请求获得操作系统内核的服务**



**系统调用与库函数的区别**

 **普通应用程序：** 可直接进行系统调用，也可以使用库函数。有的库函数涉及系统调用（如“创建一个新文件”），有的不涉及（如“取绝对值”操作）

**编程语言：** 向上提供库函数。有时会将系统调用封装成库函数，以隐藏系统调用的一些细节，使编程更加方便

**操作系统：** 向上提供系统调用，使得上层程序能请求内核的服务

**裸机**



**系统调用(按功能分类)**

应用程序通过 **系统调用** 请求操作系统的服务。而系统中的各种共享资源都由操作系统内核统一掌握，因此 **凡是与共享资源有关的操作(如存储分配、I/O操作、文件管理等)，都必须通过系统调用的方式向操作系统内核提出服务请求**，由操作系统内核代为完成。这样 **可以保证系统的稳定性和安全性** 防止用户进行非法操作

- 设备管理：完成设备的 请求/释放/启动 等功能
- 文件管理：完成文件的 读/写/创建/删除 等功能
- 进程控制：完成进程的 创建/撤销/阻塞/唤醒 等功能
- 进程通信：完成进程之间的 消息传递/信号传递 等功能
- 内存管理：完成内存的 分配/回收 等功能



**系统调用的过程**

传递系统调用参数->执行陷入指令(用户态)->执行相应的内核程序处理系统调用(内核态)->返回应用程序



1. **陷入指令**实在 **用户态** 执行的，执行陷入指令之后立即引发一个 **内中断(异常)**，使CPU进入 **内核态** 
2. **发出系统调用请求** 是在用户态，而 **对系统调用的相应处理** 在 **内核态** 下进行



## 1.4.1 操作系统体系结构

**内核** 是操作系统最基本、最核心的部分

实现操作系统内核功能的那些程序就是 **内核程序**

操作系统内核可以分为以下部分：

1. **与硬件关联较紧密的模块**

**时钟管理**->实现计时功能

**中断处理**->负责实现中断机制

**原语**->一种特殊的程序，处于操作系统最底层，是最接近硬件的部分，这种程序的运行具有`原子性`，运行时不可中断，运行时间较短且调用频繁

2. **对系统资源进行管理的功能**

- 进程管理
- 存储器管理
- 设备管理

操作系统 **内核** 需要运行在内核态

有些操作系统只保留第一部分 称作`微内核`

有1，2部分 的操作系统内核称为 `大内核`

两种不同的体系结构在运行效率上有差异,频繁的变态会降低系统性能



**操作系统体系结构**

- **大内核**->将操作系统的主要功能模块都作为系统内核，运行在核心态 Linux,UNIX
  - **优点**：高性能
  - **缺点**：内核代码庞大，结构混乱，难以维护
- **微内核**->只把最基本的功能保留在内核 Windows NT
  - **优点**：内核能力少，结构清晰，方便维护
  - **缺点**：需要频繁地在核心态和用户态之间切换，性能低

- **分层结构操作系统**

内核分多层，每层可单向调用更低一层的接口

最底层是硬件，最高层是用户接口

**优点**：便于调试和验证，自底向上逐层调试验证，易扩展和易维护，各层之间调用接口清晰固定

**缺点**：仅可调用相邻低层，难以合理定义各层的边界；效率低，不可跨层调用，系统调用执行时间长

- **模块化**

将操作系统划分为多个模块，各模块之间相互协作

内核=主模块+可加载内核模块

主模块：只负责核心功能，如进程调度，内存管理等

可加载模块：可以动态加载新模块到内核，而无需重新编译整个内核

**优点**：

1. 模块间逻辑清晰易于维护，确定模块间接口后即可多模块同时开发
2. 支持动态加载新的内核模块(如：安装设备驱动程序，安装新的文件系统模块到内核) 增强OS适应性
3. 任何模块都可以直接调用其他模块，无需采用消息传递进行通信，效率高

**缺点:**

1. 模块间的几口定义未必合理、实用
2. 模块间相互依赖，更难调试和验证

- **外核（Exokernel）**

内核负责进程调度，进程通信等功能，外核负责为用户进程分配未经抽象的硬件资源，并由外核负责保证资源使用安全

**优点**：

1. 外盒可以直接给用户进程分配"不虚拟、不抽象"的硬件资源，使用户进程可以更灵活的使用硬件资源
2. 减少了硬件资源的"映射层"，提升效率

**缺点：**

1. 降低了系统的一致性
2. 使系统变得更复杂

## 1.5 操作系统的引导(boot)

1. CPU从一个特定主存位置开始，取指令，执行ROM中的`引导程序`（即自举程序) (先硬件自检，再开机)
2. 将磁盘的第一块->引导记录读入内存，执行磁盘引导程序，扫描分页表
3. 将活动分区(又称主分区，即安装了操作系统的分区)读入分区引导记录，执行其中的程序
4. 从根目录下找到完整的操作系统初始化程序(即 启动管理器)并执行，完成"开机"的一系列操作



## 1.6 虚拟机

`虚拟机`：使用虚拟化技术，将一台物理机器虚拟化为多台虚拟机器(Virtual Machine,VM) 每个虚拟机器都可以独立运行一个操作系统

同义词:虚拟机管理系统，虚拟机监控程序，Virtual Machine Monitor/Hypervisor

第一类VMM->直接运行在硬件上(内核控件)->用户空间分为虚拟用户空间和虚拟内核空间

第二类VMM->运行在宿主操作系统上

**两类VMM的对比**

|                    |                          第一类VMM                           |                          第二类VMM                           |
| :----------------: | :----------------------------------------------------------: | :----------------------------------------------------------: |
| 对物理资源的控制权 |         直接运行在硬件之上，能直接控制和分配物理资源         |       运行在Host OS之上，依赖于Host OS为其分配物理资源       |
|    资源分配方式    |    在原本的硬盘上自行分配存储空间(分配未经抽象的物理硬件)    | GuestOS拥有自己的虚拟磁盘，该盘事实上使Host OS 文件系统中的一个大文件。GuestOS分配到的内存使虚拟内存 |
|        性能        |                           性能更好                           |                性能更差，需要HostOS作为"中介"                |
| 可支持的虚拟机数量 | 更多，不需要和HostOS竞争资源，相同的硬件资源可以支持更多的虚拟机 | 更少，Host OS本身需要使用物理资源，Host OS上运行的其他进程也需要物理资源 |
|  虚拟机的可迁移性  |                             更差                             | 更好，只需导出虚拟机镜像文件即可迁移到另一台HostOS上，商业化应用更广泛 |
|      运行模式      |    第一类VMM在最高特权级(Ring 0)，可以执行最高特权的指令     | 第二类VMM部分运行在用户态，部分运行在内核态（虚拟机驱动程序）。GuestOS 发出的系统调用会被VMM截获，并转化为VMM对HostOS的系统调用 |

# 第二章 进程管理

## 2.1.1 进程的概念、组成、特征

**程序**：是 **静态的**，就是个存放在磁盘里的可执行文件，是一系列的指令集合

`进程`(Process)：是 **动态的**，是程序的一次执行过程



当进程被创建时，操作系统会为该进程分配一个 **唯一的、不重复**的进程号--PID(Process ID,进程ID)

操作系统要记录PID、进程所属用户ID（UID）基本的进程描述信息，可以让操作系统区分各个进程。还要记录给进程分配了哪些资源



这些信息都被保存在一个**数据结构** `PCB`(Process Control Block)中，即 **进程控制块** 操作系统需要对各个并发运行的进程进行管理，**但凡管理时所需要的信息，都会被放在PCB中**，PCB时进程存在的唯一标志，当进程被创建时，操作系统为其创建PCB，当进程结束时，会回收其PCB



**PCB一般由以下部分组成：**

- 进程描述信息
  - 进程标识符PID
  - 用户标识符UID
- 进程控制和管理信息
  - CPU、磁盘、网络流量使用情况统计
  - 进程当前状态：就绪态/阻塞态/运行态...
- 资源分配清单
  - 正在使用哪些文件
  - 正在使用哪些内存区域
  - 正在使用哪些I/O设备
- 处理机相关信息
  - 如PSW、PC等等各种寄存器的值(用于实现进程切换)



一个**进程的实体(进程映像)**由PCB、程序段、数据段组成。

进程是动态的，进程实体是静态的(反应进程在某一时刻的状态)



**进程的概念：** 进程实体的运行过程，是系统进行资源分配和调度的一个独立单位



**进程的特征：**

- **动态性**（最基本特征）->进程是程序的一次执行过程，是动态地产生，变化和消亡的
- **并发性**->内存中有多个进程实体，各进程可并发执行
- **独立性**->进程是能独立运行，独立获得资源、独立接受调度的基本单位
- **异步性**->各进程按各自独立的、不可预知的速度向前推进，操作系统要提供"进程同步机制"来解决异步问题
- **结构性**->每个进程都会配置一个PCB。结构上看，进程由程序段、数据段、PCB组成



## 2.1.2 进程的状态与转换、进程的组织

1. 创建态与就绪态

进程正在被创建时，它的状态是`创建态`，这个阶段操作系统会为进程分配资源，初始化PCB

当进程创建完成后，便进入`就绪态`(Ready),处于就绪态的进程已经具备运行条件，但由于没有空闲CPU，就暂时不能运行

2. 运行态

系统中可能会由很多个进程都处于就绪态，当CPU空闲时，操作系统就会选择一个就绪进程，让它上处理机运行。

如果一个进程此时在CPU上运行，那么这个进程处于`运行态`(Running)，CPU会执行该进程对应的程序

3. 阻塞态

在进程运行过程中，可能会 **请求等待某个事件的发生** (等待某种系统资源的分配，或者等待其他进程的响应)

在这个事件发生之前，进程无法继续往下执行，这是操作系统会让这个进程下CPU，并让它进入`阻塞态`(Blocked)

当CPU空闲时，又会选择另一个就绪态进程上CPU运行

4. 终止态

一个进程可以执行exit系统调用，请求操作系统终止该进程。此时该进程会进入`终止态`，操作系统会让该进程下CPU，并回收内存空间等资源，最后还要回收该进程的PCB。当上述工作完成时，这个进程就彻底消失了

## 2.1.3 进程控制

进程控制的主要功能是对系统中的所有进程实施有效的管理，它由创建新进程、撤销已有进程、实现进程状态转换等功能



**原语**

一种特殊的程序，它的执行具有原子性，使用原语进行进程控制

如果不能进程转换的过程不具原子性，那么就有可能导致操作系统中的某些关键数据结构信息不统一，会影响操作系统进行别的管理工作



**如何实现原语的原子性**

使用`关中断指令`和`开中断指令`这两个**特权指令**实现**原子性**

关中断指令：CPU不再例行检查中断信号，直到执行开中断指令后



**进程控制相关原语**

**进程的创建**

**创建原语**

申请空白PCB，为进程分配资源，初始化PCB，将PCB插入就绪队列

引起进程创建的事件：用户登录，作业调度，提供服务，应用请求



**进程的终止**

**撤销原语**

从PCB集合中找到终止进程的PCB

若进程正在运行，立即剥夺CPU使用权，将CPU分配给其他进程

终止其所有子进程

将该进程所拥有的所有资源归还给父进程或操作系统

删除PCB



引起进程终止的事件：正常结束、异常结束、外界干预



**进程的阻塞**

**阻塞原语**

找到要阻塞的进程对应的PCB

保护进程运行现场，将PCB状态信息设置为"阻塞态"，暂停进程运行

将PCB插入相应事件的等待队列

事件：需要等待系统分配某种资源，需要等待相互合作的其他进程完成工作



**进程的唤醒**

**唤醒原语**

在事件等待队列中找到PCB

将PCB从等待队列移除，设置进程为就绪态

将PCB插入就绪队列，等待被调度

事件：等待的事件发生->**因为什么事件阻塞，就因什么事件完成而唤醒**



**阻塞原语与唤醒原语必须成对使用**



**进程的切换**

**切换原语**

1. 将`运行环境信息(进程上下文)`(Context)存入PCB

在进程切换时，现在PCB中保存这个进程的运行环境 PSW PC IR 通用寄存器...

2. PCB移入相应队列

3. 选择另一个进程执行，并更新其PCB

4. 根据PCB恢复新进程所需的运行环境

当原来的进程再次投入运行时，可以**通过PCB恢复它的运行环境**

 

事件:当前进程时间片到，有更高优先级的进程到达，当前进程主动阻塞，当前进程终止



**进程控制原语所做的三件事:**

1. 更新PCB中的信息->修改进程状态(state),保护/恢复运行环境
2. 将PCB插入合适的队列
3. 分配/回收资源



## 2.1.4 进程通信（IPC)

两个进程之间产生数据交互

进程是分配系统资源的单位(包括内存地址空间)，因此各进程拥有的内存地址空间相互独立

为了保证安全、一个进程不能直接访问另一个进程的地址空间

1. **共享存储**

申请一个共享存储区，映射到进程的虚拟地址

要保证各个进程对共享空间的访问应该是互斥的(**进程自身实现互斥**)

各个进程可使用操作系统内核提供的同步互斥工具(如P,V操作)



**基于存储区**的共享：操作系统在内存中划出一块共享存储区，数据的形式，存放位置都由通信进程控制，而非操作系统。这种共享方式速度很快，是一种**高级通信**方式



**基于数据结构**的共享：比如共享空间里只能存放一个长度为10的数组。这种共享方式速度慢、限制多，是一种**低级通信**方式



2. **消息传递**

进程间的数据交换以 **格式化的消息**(Message)为单位。进程通过操作系统提供的"发送消息/接收消息"两个**原语**进行数据交换



格式化消息：消息头+消息体

消息头：发送进程ID、接收进程ID、消息长度等格式化信息



直接通信方式->指明接收进程的ID

消息直接挂到接收进程的消息队列里

	**发送原语** send(Q,msg)
	
	**接收原语** receive(P,&msg)

间接通信方式->通过"信箱"间接地通信，又叫做"信箱通信方式"

消息先发到中间体(信箱)

	**发送原语**send(A,msg)
	
	**接受原语** receive(A,&msg)



3. **管道通信**

”管道"是一个特殊的共享文件，又称为pipe文件。本质是内存中开辟的一个大小固定的内存缓冲区

**具有先进先出的特性**

管道只能采用**半双工通信**，某一时间段内只能实现单向的传输。如果要实现**双向同时通信**，则需要**设置两个管道**

各进程要**互斥**地访问管道(由操作系统实现)

当管道写满时，写进程将阻塞，直到读进程将管道里的数据取走，即可唤醒写进程

当管道读空时，读进程将阻塞，直到写进程向管道里写入数据，即可唤醒读进程

管道中的数据一旦被读出，就彻底消失。因此，当多个进程读同一个管道时，可能会错乱。对此，通常由两种解决方式：

1. 一个管道允许多个写进程，一个读进程(408高教社官方答案)
2. 一个管道允许由多个写进程，多个读进程，但系统会让各个读进程轮流从管道中读数据(Linux方案)



## 2.1.5 线程的概念

**线程**是一个最基本的CPU执行单元，也是**程序执行流的最小单位**。



**资源分配、调度**

进程是资源分配的基本单位，线程是调度的基本单位



**并发性**

引入线程后，各线程之间也能并发，提升了并发度



**系统开销**

线程间并发，如果是统一进程内的线程切换，不需要切换线程环境，系统开销小。

引入线程后，并发所带来的系统开销减小



**线程的属性**

- 线程是处理机调度的代为
- 多CPU计算机中，各个线程可占用不同的CPU
- 每个线程都有一个线程ID,线程控制块TCB
- 线程也有就绪、阻塞、运行三种基本状态
- 线程几乎不拥有系统资源
- 统一进程的不同线程共享进程的资源
- 由于共享内存地址，同一进程中的线程间通信甚至无需系统干预
- 同一进程中的线程切换，不会引发进程切换
- 不同进程中的线程切换，会引发进程切换
- 切换同进程内的线程，系统开销很小
- 切换进程，系统开销大



## 2.1.6 线程实现方式和多线程模型

### 线程的实现方式

**用户级线程（User-Level Thread)**

使用线程库实现多个线程并发运行

线程的管理工作由应用程序通过线程库完成

线程切换不需要CPU从用户态转换到内核态

操作系统不能"意识"到用户级线程的存在

优点：用户级线程的切换在用户空间即可完成，不需要切换到核心态，线程管理的系统开销小，效率高

缺点：当一个用户线程被阻塞后，整个进程都会被阻塞，并发度不高。多个线程不可再多核处理机上并行运行



**内核级线程(Kernel-Level Thread)**

由操作系统支持的线程

线程的管理工作由操作系统完成

操作系统会为每个内核级线程建立相应的TCB(Thread Control Block,线程控制块)，通过TCB对线程进行管理

线程切换需要CPU从用户态转换到内核态

操作系统能"意识到"内核级线程的存在

优点：当一个线程被阻塞后，别的线程还可以继续执行，并发能力强。多线程可在多核处理器上并行执行

缺点：一个用户进程会占用多个内核级线程，线程切换由操作系统内核完成，需要切换到核心态，因此线程管理的成本高，开销大



### 多线程模型

**一对一模型**：一个用户级线程映射到一个内核级线程

优点：当一个线程被阻塞后，别的线程还可以继续执行，并发能力强。多线程可在多核处理器上并行执行

缺点：一个用户进程会占用多个内核级线程，线程切换由操作系统内核完成，需要切换到核心态，因此线程管理的成本高，开销大

**多对一模型**：多个用户级线程映射到一个内核级线程

优点：用户及线程的切换只需要再用户态即可完成，不需要切换到核心态，线程管理的系统开销小，效率高

缺点：当一个用户级线程被阻塞后，整个进程都会被阻塞，并发度不高。多个线程不能再多核处理机上并行运行



**操作系统只"看得见"内核级线程，内核级线程才是处理机分配的单位**



**多对多模型**:把n个用户级线程映射到m个内核级线程(n>=m)。每个用户进程对应m个内核级线程

克服了多对一模型并发度不高的缺点，又克服了一对一模型中一个用户进程占用太多内核级线程，开销太大的缺点



**用户级线程是"代码逻辑"的载体，内核级线程是"运行机会"的载体**



## 2.1.7 线程的状态与转换

**线程的状态与转换**

![](image/%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E7%9A%84%E8%BD%AC%E6%8D%A2.png)

**线程的组织与控制**

TCB（线程控制块)

线程标识符->TID

程序计数器PC->线程目前执行到哪

其他寄存器->线程运行的中间结果

堆栈指针->堆栈保存函数调用信息、局部变量等

线程运行状态->运行/就绪/阻塞

优先级->线程调度、资源分配



**线程表(Thread table)**

可将多个TCB组织成一张线程表



## 2.2.1 调度的概念和层次

当有大量任务需要处理时，由于资源有限，有些任务无法同时处理。这就需要确定某种规则来决定处理这些任务的顺序，这就是"调度"所研究的问题



### **调度的三个层次**

作业：一个具体的任务

用户向系统提交一个作业，类似于用于让操作系统启动一个程序



**高级调度(作业调度) 无->创建态->就绪态** 

外存->内存 (面向作业)

按一定的原则从外存的作业后背队列中挑选一个作业调入内存，并创建进程。每个作业只调入一次，调出一次。作业调入后会建立PCB，调出时才撤销PCB。



**低级调度（进程调度/处理机调度）就绪态->运行态**

内存->CPU

按照某种策略从就绪队列中选取一个进程，将处理机分配给它。



进程调度是操作系统中**最基本的一种调度**，在一般的操作系统中都必须配置进程调度。

进程调度的**频率很高**，一般几十毫秒一次



**中级调度 挂起态->就绪态(阻塞挂起->阻塞态)**

外存->内存(面向进程)

内存不够时，可将某些进程的数据调出外存。等内存空闲或者进程需要运行时再重新调入内存。

暂时调到外存等待的进程状态为**挂起状态**。被挂起的进程PCB会被组织成**挂起队列**

**中级调度(内存调度)**--按照某种策略决定将那个处于挂起状态的进程重新调入内存.



**进程的挂起态与七状态模型(了解)**

暂时调到外存等待的进程状态为**挂起状态**(挂起态,suspend)

挂起态又可进一步细分为**就绪挂起**、**阻塞挂起**两种状态

![](image/%E4%B8%83%E7%8A%B6%E6%80%81%E6%A8%A1%E5%9E%8B.png)

## 2.2.2 进程调度的时机、切换与过程、调度方式

### 进程调度的时机

**进程调度**(低级调度)，就是按照某种算法从就绪队列中选择一个进程为其分配处理机



当前运行的进程**主动放弃**处理机:

- 进程正常终止
- 运行过程中发生异常而终止
- 进程主动请求阻塞(如 等待I/O)

当前运行的进程**被动放弃**处理机:

- 分给进程的时间片用完
- 有更紧急的事需要处理(如I/O中断)
- 有更高优先级的进程进入就绪队列



**不能进行**进程调度与切换的情况

1. 在**处理中断的过程中**。中断处理过程复杂，与硬件密切相关，很难做到在中断处理过程中进行进程切换
2. 进程在**操作系统内核程序临界区中**

`临界资源`：一段时间内只允许一个进程使用的资源。各进程需要**互斥地**访问临界资源。

`临界区`：访问临界资源的那段代码

`内核程序临界区`：用于访问某种内核数据结构，比如进程的就绪队列（由各就绪进程的PCB组成） 进入内核临界区后，进程需要**独占式访问**，理论上必须加锁，以防止其他进程入内，解锁前不应切换到其他进程，以加快临界区的释放。

3. 在**原子操作过程中**(原语)



### 进程调度的方式

**非剥夺调度方式**，又称**非抢占方式**。即，只允许进程主动放弃处理机。在运行过程中

即使有更紧迫的任务到达，当前进程依然会继续使用处理机，知道该进程终止或主动要求进入阻塞态

实现简单，系统开销小但是无法及时处理紧急任务，适合于早期的批处理系统、



**剥夺调度方式**，又称**抢占方式**。当一个进程正在处理机上执行时，如果有一个更重要或更紧迫的进程需要使用处理机，则立即停止正在执行的进程，将处理机分配给更重要紧迫的那个进程

可以有限处理更紧急的进程，也可实现让各进程按时间片轮流执行的功能(通过时钟中断)。适合于分时操作系统、实时操作系统



### 进程的切换与过程

"狭义的进程调度"与"进程切换"的区别：

**侠义的进程调度**指的是从就绪队列中**选中一个要运行的进程**。(这个进程可以是刚刚被暂停执行的进程，也可能时另一个进程,后一种情况就需要**进程切换**)

**进程切换**是指一个进程让出处理机，由另一个进程占用处理机的过程

**广义的进程调度**包含了选择一个进程和进程切换两个步骤

进程切换的过程主要完成了:

1. 对原来运行进程各种数据的保存
2. 对新的进程各种数据的回复



**进程切换是有代价的**,因此过于频繁的进程调度、切换，必然会使整个**系统的效率降低**

## 2.2.3 调度器和调度程序(scheduler)

调度程序决定:

让谁运行?--调度算法

运行多长时间?--时间片大小



**闲逛进程**

没有其他就绪进程时，运行闲逛程序

特性：

- 优先级最低
- 可以是0地址指令，占一个完整的指令周期
- 能耗低



## 2.2.4 调度算法的评价指标
