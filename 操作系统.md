# Part Ⅲ 内存管理

## 内存的基本知识

**内存可存放数据。程序执行前需要先放到内存中才能被CPU处理**

why?缓和CPU和硬盘之间的速度矛盾



**逻辑地址和物理地址**

逻辑地址：程序经过编译、链接后生成的指令中指明的是逻辑地址，即相对于进程的起始地址而言的地址

物理地址：也叫绝对地址，指令实际存放在内存中的地址



**如何将指令中的逻辑地址转换为物理地址**

1. 绝对装入

在编译时，如果知道程序将放到内存中的哪个位置，编译程序将生成绝对地址的目标代码，装入程序按照装入模块中的地址，将程序和数据装入内存。

只适用于单道程序环境

2. 静态重定位

又叫可重定位装入。编译、链接后的装入模块都是从0开始的。可根据内存的当前情况，将装入模块装入到内存的适当位置。即装入时，对地址进行“重定位”，将逻辑地址变换为物理地址

特点：在一个作业装入内存时，必须分配其要求的全部内存空间，如果没有足够的内存，就不能装入该作业，作业一旦进入内存之后，在运行期间就不能再移动，也不能再申请内存空间

3. 动态重定位

又叫动态运行时装入。装入程序把装入模块装入内存后，并不会立即把逻辑地址转换为物理地址，而是把地址转换推迟到程序真正要执行时才进行。即装入内存的地址依然是逻辑地址。这种方式需要一个重定位寄存器的支持

特点：允许程序在内存中发生移动



**从写程序到程序运行**

编译：由编译程序将用户源代码编译成若干个目标模块

链接：由链接程序将编译后形成的一组目标模块(c语言中的.o文件)，以及所需要的库函数链接在一起，形成一个完整的装入模块(windows中的 .exe)

装入：由装入程序将装入模块装入内存运行



**链接的三种方式**

1. 静态链接：程序运行之前，先将各模块及它们所需要的库函数连接成一个完整的可执行文件，之后不再拆开
2. 装入时动态链接：将各目标模块装入内存时，边装入边链接的链接方式
3. 运行时动态链接：在程序执行过程中需要该目标模块时，才对它进行链接。

​	优点：便于修改和更新，便于实现对目标模块的共享



## 内存管理的概念

操作系统作为系统资源的管理者，需要对内存进行管理

1. 内存空间的分配与回收

操作系统如何记录哪些内存区域已经被分配出去了，哪些还是空闲的？

进程装入内存时可以放在很多位置，应该放在哪？

进程运行结束后，如何将进程占用的内存空间回收？

2. 内存空间的扩展

操作系统需要提供某种技术从逻辑上对内存空间进行扩充

3. 地址转换

操作系统需要提供地址转换功能，负责程序的逻辑地址与物理地址的转换

三种装入方式

- 绝对装入：编译器负责地址转换(单道程序阶段)
- 可重定位装入：装入程序负责地址转换(早期多道批处理系统)
- 动态运行时装入：运行时才进行地址转换(现代操作系统)

4. 内存保护

操作系统需要提供内存保护功能。保证各进程在各自存储空间内运行，互不干扰

方法一：在CPU中设置一对上、下限寄存器，存放进程地址的上、下限地址。进程的指令要访问某个地址时，CPU检查是否越界

方法二：采用重定位寄存器(基址寄存器)和界地址寄存器(限长寄存器)进行越界检查。重定位寄存器中存放的是进程的起始物理地址。界地址寄存器存放的是进程的最大逻辑地址

![](image/%E7%95%8C%E5%9C%B0%E5%9D%80%E5%AF%84%E5%AD%98%E5%99%A8.png)

## 覆盖与交换

**覆盖技术**

将程序分为多个段(多个模块)，常用的段常驻内存，不常用的段在需要时调入内存

内存中分一个`固定区`和若干个`覆盖区`，需要常驻内存的段放在固定区中，调入后在运行结束之前就不再调出

按照自身逻辑结构，让那些不可能同时被访问的程序段共享同一个覆盖区

![](image/%E8%A6%86%E7%9B%96%E6%8A%80%E6%9C%AF.png)

必须由程序员声明覆盖结构，操作系统完成自动覆盖

缺点：`对用户不透明`，增加用户编程负担



**交换技术**

内存空间紧张时，系统将内存中某些进程暂时换出外存，把外存中某些已具备运行条件的进程换入内存

暂时换出外存等待的进程状态为`挂起状态`(suspend)

挂起状态又可分为就绪挂起、阻塞挂起两种状态



三个问题

1. 应该在外存的什么位置保存被换出的进程

具有对换功能的操作系统时，通常将磁盘空间分为文件区和对换区

对换区的I/O速度比文件区的更快

2. 什么时候应该交换

交换通常在许多进程运行且内存吃紧时进行，二系统负荷降低就暂停

3. 应该换出哪些进程

- 阻塞进程
- 优先级低的进程
- 为了防止优先级低的进程在被调入内存后很快又被换出，有的系统还会考虑进程在内存的驻留时间



## 连续分配管理方式

连续分配：为用户进程分配的必须是连续的内存空间

**单一连续分配**

内存被分为系统区和用户区

系统区：常位于内存的低地址部分，用于存放操作系统相关数据

用户区：用于存放用户进程相关数据

内存中只能有一道用户程序，用户程序独占整个用户区空间

优点：实现简单，无外部碎片，不一定需要采用内存保护

缺点：只能用于单用户、单任务的操作系统中，有内部碎片，存储器的利用率很低



**固定分区分配**

将用户空间划分为若干个大小相同的分区，在每个分区中只装入一道作业，这样就形成了最早的、最简单的可运行多道程序的内存管理方式

两种固定分配方式：

1. 分区大小相等 

缺乏灵活性，适合用于一台计算机控制多个相同对象的场合

2. 分区大小不等

增加了灵活性，可以满足不同大小的进程需求，根据系统中运行的作业大小情况进行划分



分区说明表

一种数据结构(数组或链表)

来实现各个分区的分配与回收。每个表项对应一个分区，通常按分区大小排列。每个表项包括对应分区的大小、起始地址、状态(是否分配)



固定分区分配方式的优缺点

优点：实现简单，无外部碎片

缺点：

- 当用户程序太大时，可能所有的分区都不能满足需求，此时不得不采用覆盖技术来解决问题，这会降低性能

- 会产生内部碎片，降低内存利用率



**动态分区分配**

又叫可变分区分配，这种分配方式不会预先划分内存分区，而是在进程装入内存时，根据进程的带线啊哦动态地建立分区，并使分区的大小正好适合进程的需要。



三个问题：

1. 操作系统使用什么数据结构记录内存的使用情况

空闲分区表

每个空闲分区对应一个表项，表项中包含分区号、分区大小、分区起始地址等信息

空闲分区链

每个分区的起始部分和末尾部分分别设置前向指针和后向指针。起始部分处还可以记录分区大小等信息

2. 当有很多空闲分区都能满足需求时，应该选择哪个分区进行分配

按照`动态分区分配算法`，从空闲分区表或空闲分区连中选出一个分区分配给该作业

3. 如何进行分区的分配与回收

分配：对空闲分区表某个表项进行修改或删除

回收：对空闲分区表某个表项进行更新或增加一项

动态分区分配没有内部碎片，但是有外部碎片



内部碎片：分配给某进程的内存区域中，有些部分没有用上

外部碎片：内存中的某些空闲分区由于太小而难以利用



通过紧凑（拼凑，Compaction）技术来解决外部碎片



## 动态分区分配算法

**首次适应算法（first fit）**

每次从低地址开始查找，找到第一个能满足大小的空闲分区

空闲分区以地址递增的次序排列。每次分配内存时顺序查找空闲分区链或空闲分区表，找到大小能满足要求的第一个空闲分区

**最佳适应算法**

尽可能地留下大片的空闲区，优先使用更小的空闲区

空闲分区按容量递增次序链接，每次分配内存时查找空闲分区链（表），找到满足要求的第一个空闲分区

缺点：会留下越来越多的，很小的，难以利用的内存块，会产生很多外部碎片

**最坏适应算法**

空闲分区按容量递减次序链接。

缺点：每次都选最大的分区进行分配，虽然可以让分配后留下的空闲区更大，更可用，但是这种方式会导致较大的连续空闲区被迅速用完，如果后续有大进程到达，就没有内存分区可用了

**邻近适应算法**

每次都从上次查找结束的位置开始检索

空闲分区以地址递增的次序排列(循环链表)。每次分配内存时从上一次查找结束位置开始查找空闲分区链或空闲分区表，找到大小能满足要求的第一个空闲分区



综合来看，首次适应算法的综合性能是最好的



## 基本分页存储管理的基本概念

**分页存储**

​	将内存空间分为一个个大小相同的分区，每个分区就是一个`帧`(页帧，页框，内存块，物理块，物理页面)。每个页帧有一个编号，即帧号，帧号从0开始

​	将进程的逻辑地址空间也分为与页帧大小相等的一个个部分，每个部分称为一个`页`(页面)。每个页面也有一个编号，即"页号"，页号也是从0开始

​	

操作系统以帧为单位为各个进程分配内存空间。进程的页面与内存的帧有一一对应的关系，各个页面不必连续存放，可以放到不相邻的各个帧中



**页表**

操作系统为每个进程建立一张`页表`,页表通常存储在PCB中

- 一个进程对应一张页表
- 进程的每个页面对应一个页表项
- 每个页表项由页号和帧号组成
- 页表记录进程页面和实际存放的帧之间的映射关系



要点：

- 页表项所占字节数计算

- 页表项时连续存放的，因此页号可以是隐含的，不占存储空间

- 地址的转换

- 确定一个逻辑对应的页号、页内偏移量

页号=逻辑地址/页面长度（向下取整）

页内偏移量=逻辑地址%页面长度

逻辑地址=页号+页内偏移量

![](image/%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80.png)



**逻辑地址结构**

分页存储管理的逻辑地址结构如下所示

| 页号P | 页内偏移量W |
| ----- | ----------- |
| M位   | K位         |

$2^M$个页面,$2^K$个内存单元



## 基本地址变换机构

**基本地址变换机构**

基本地址变换机构可以借助进程的页表将逻辑地址转换为物理地址

`页表寄存器`(PTR),存放页表在内存中的起始地址F和页表长度M

进程未执行时，页表的起始地址和页表长度存放在进程控制块PCB中，当进程被调度时，操作系统内核会将他们放到页表寄存器中



**工作流程**

![](image/%E5%9F%BA%E6%9C%AC%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2%E6%9C%BA%E6%9E%84%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png)



## 具有快表的地址变换机构

**快表TLB**

又叫做`联想寄存器`(TLB,translation lookaside buffer)，是一种访问速度比内存快很多的告诉缓存，用来存放最近访问的页表项的副本，可以加速地址变换的速度，与此对应，内存中的页表常称为慢表

![](image/%E5%85%B7%E6%9C%89%E5%BF%AB%E8%A1%A8%E7%9A%84%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2%E6%9C%BA%E6%9E%84%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png)

快表命中->一次访存

快表未命中->两次访存



**局部性原理**

时间局部性：如果执行了程序中的某条指令(数据)，那么不久后这条指令(数据)很可能再次执行

空间局部性：一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也很有可能被访问



## 两级页表

**单极页表存在的问题**

1. 页表必须连续存放，当页表很大时，需要占用很多个连续的帧

2. 局部性原理可知，进程在一段时间内只需要访问某几个页面就可以正常运行了，没必要让整个页表都常驻内存

**解决方案**

将页表进行分组，使每个内存块刚好可以放入一个分组。另外，要为离散分配的页表再建立一张页表，称为`页目录表`，`外层页表`或`顶层页表`



**两级页表的原理、地址结构**

地址机构

| 一级页号 | 二级页号 | 页内偏移量 |
| -------- | -------- | ---------- |

![](image/%E4%BA%8C%E7%BA%A7%E9%A1%B5%E8%A1%A8.png)

第二个问题的解决方案：可以在需要访问页面时才把页面调入内存(虚拟存储技术)，在页表项中增加一个标志位，用于表示该页面是否已经调入内存



**几个细节**

多级页表机制:各级页表的大小不能超过一个页面

二级页表的访存次数：

1. 访问内存中的页目录表
2. 访问内存中的二级页表
3. 访问目标内存单元

N级页表访问一个逻辑地址需要N+1次访存



## 基本分段存储管理

与分页的最大区别--离散分配时所分配地址空间的基本单位不同

**分段**

进程中的地址空间按照程序自身的逻辑关系划分为若干个段，每个段有一个段名（在低级语言中，程序员使用段名来编程），每段从0开始编址

内存分配规则：以段为单位进行分配，每个段在内存中占据连续空间，但各段之间可以不相邻

优点：按逻辑功能模块划分，用户编程更方便，程序可读性更高



逻辑地址结构

| 段号 | 段内地址 |
| ---- | -------- |



**段表**

每个进程都有一个段映射表，简称段表

每个表项由段号，段长，基址组成

![](image/%E6%AE%B5%E8%A1%A8.png)

每个段表示的长度时相同的

段号是可以隐含的，不占存储空间



**地址变换**

![](image/%E6%AE%B5%E8%A1%A8%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2.png)



**分段、分页的对比**

页是信息的物理单位、段是信息的逻辑单位

分页的目的是实现离散分配，提高内存利用率。分段的主要目的是更好地满足用户需求，一个段通常包含着一组属于一个逻辑模块的信息

分页对用户是不可见的，分段对用户是可见的

页的大小固定，由系统决定。段的长度不固定，由用户决定

分页的用户进程地址空间是一维的，分段的用户进程地址是二维的，既要给出段名，又要给出段内地址

分段比分页更容易实现信息的共享和保护



## 段页式管理方式

**分页、分段管理的优缺点分析**

分页管理

优点：内存利用率高，不会产生外部碎片，只会有少量内部碎片

缺点：不方便按照逻辑模块实现信息的共享与保护



分段管理

优点：很方便按照逻辑模块实现信息的共享与保护

缺点：如果段长过大，为其分配很大的连续空间会很不方便。会产生外部碎片



**分段+分页=段页式管理**

将进程按照逻辑模块分段，再将各分段分页

再将内存地址分为大小相等的帧



**段页式管理的逻辑地址结构**

| 段号 | 页号 | 页内偏移量 |
| ---- | ---- | ---------- |

分段过程用户可见，分页式用户不可见的

段页式管理的地址结构是二维的



**段表、页表**

段表表项：段号，页表长度，页表存放块号

页表：页号，内存块号



**地址转换过程**

![](image/%E6%AE%B5%E9%A1%B5%E5%BC%8F%E7%AE%A1%E7%90%86%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2.png)

三次访存

可引入快表机制
